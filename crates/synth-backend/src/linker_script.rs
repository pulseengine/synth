//! Linker Script Generator for ARM Cortex-M
//!
//! Generates GNU ld linker scripts (.ld files) for embedded ARM targets

use synth_core::Result;

/// Memory region definition
#[derive(Debug, Clone)]
pub struct MemoryRegion {
    /// Region name (e.g., "FLASH", "RAM")
    pub name: String,
    /// Start address
    pub origin: u32,
    /// Size in bytes
    pub length: u32,
    /// Attributes (r=read, w=write, x=execute)
    pub attributes: String,
}

/// Linker script generator
pub struct LinkerScriptGenerator {
    /// Memory regions
    regions: Vec<MemoryRegion>,
    /// Entry point symbol
    entry_point: String,
    /// Stack size
    stack_size: u32,
    /// Heap size
    heap_size: u32,
}

impl LinkerScriptGenerator {
    /// Create a new linker script generator with default STM32 memory layout
    pub fn new_stm32() -> Self {
        let mut regions = Vec::new();

        // Default STM32F4 memory layout
        regions.push(MemoryRegion {
            name: "FLASH".to_string(),
            origin: 0x08000000,
            length: 512 * 1024,  // 512KB
            attributes: "rx".to_string(),
        });

        regions.push(MemoryRegion {
            name: "RAM".to_string(),
            origin: 0x20000000,
            length: 128 * 1024,  // 128KB
            attributes: "rwx".to_string(),
        });

        Self {
            regions,
            entry_point: "Reset_Handler".to_string(),
            stack_size: 4096,   // 4KB stack
            heap_size: 8192,    // 8KB heap
        }
    }

    /// Create a custom linker script generator
    pub fn new() -> Self {
        Self {
            regions: Vec::new(),
            entry_point: "Reset_Handler".to_string(),
            stack_size: 4096,
            heap_size: 0,
        }
    }

    /// Add a memory region
    pub fn add_region(&mut self, region: MemoryRegion) -> &mut Self {
        self.regions.push(region);
        self
    }

    /// Set the entry point
    pub fn with_entry_point(mut self, entry: String) -> Self {
        self.entry_point = entry;
        self
    }

    /// Set stack size
    pub fn with_stack_size(mut self, size: u32) -> Self {
        self.stack_size = size;
        self
    }

    /// Set heap size
    pub fn with_heap_size(mut self, size: u32) -> Self {
        self.heap_size = size;
        self
    }

    /// Generate the linker script
    pub fn generate(&self) -> Result<String> {
        let mut script = String::new();

        // Header comment
        script.push_str("/* Generated Linker Script for ARM Cortex-M */\n");
        script.push_str("/* Generated by Synth */\n\n");

        // Entry point
        script.push_str(&format!("ENTRY({})\n\n", self.entry_point));

        // Stack and heap symbols
        script.push_str(&format!("_stack_size = 0x{:X};\n", self.stack_size));
        if self.heap_size > 0 {
            script.push_str(&format!("_heap_size = 0x{:X};\n", self.heap_size));
        }
        script.push_str("\n");

        // Memory regions
        script.push_str("MEMORY\n{\n");
        for region in &self.regions {
            script.push_str(&format!(
                "  {} ({}): ORIGIN = 0x{:08X}, LENGTH = 0x{:X}\n",
                region.name, region.attributes, region.origin, region.length
            ));
        }
        script.push_str("}\n\n");

        // Sections
        script.push_str("SECTIONS\n{\n");

        // .isr_vector section (interrupt vector table)
        script.push_str("  .isr_vector :\n");
        script.push_str("  {\n");
        script.push_str("    . = ALIGN(128);  /* Vector table must be 128-byte aligned */\n");
        script.push_str("    KEEP(*(.isr_vector))\n");
        script.push_str("    . = ALIGN(4);\n");
        script.push_str("  } >FLASH\n\n");

        // .text section (code)
        script.push_str("  .text :\n");
        script.push_str("  {\n");
        script.push_str("    . = ALIGN(4);\n");
        script.push_str("    *(.text)\n");
        script.push_str("    *(.text*)\n");
        script.push_str("    *(.glue_7)         /* ARM/Thumb interworking */\n");
        script.push_str("    *(.glue_7t)\n");
        script.push_str("    *(.eh_frame)\n");
        script.push_str("    KEEP (*(.init))\n");
        script.push_str("    KEEP (*(.fini))\n");
        script.push_str("    . = ALIGN(4);\n");
        script.push_str("    _etext = .;\n");
        script.push_str("  } >FLASH\n\n");

        // .rodata section (read-only data)
        script.push_str("  .rodata :\n");
        script.push_str("  {\n");
        script.push_str("    . = ALIGN(4);\n");
        script.push_str("    *(.rodata)\n");
        script.push_str("    *(.rodata*)\n");
        script.push_str("    . = ALIGN(4);\n");
        script.push_str("  } >FLASH\n\n");

        // .ARM.extab and .ARM.exidx sections (exception handling)
        script.push_str("  .ARM.extab :\n");
        script.push_str("  {\n");
        script.push_str("    *(.ARM.extab* .gnu.linkonce.armextab.*)\n");
        script.push_str("  } >FLASH\n\n");

        script.push_str("  .ARM.exidx :\n");
        script.push_str("  {\n");
        script.push_str("    __exidx_start = .;\n");
        script.push_str("    *(.ARM.exidx* .gnu.linkonce.armexidx.*)\n");
        script.push_str("    __exidx_end = .;\n");
        script.push_str("  } >FLASH\n\n");

        // .preinit_array, .init_array, .fini_array (C++ constructors/destructors)
        script.push_str("  .preinit_array :\n");
        script.push_str("  {\n");
        script.push_str("    PROVIDE_HIDDEN (__preinit_array_start = .);\n");
        script.push_str("    KEEP (*(.preinit_array*))\n");
        script.push_str("    PROVIDE_HIDDEN (__preinit_array_end = .);\n");
        script.push_str("  } >FLASH\n\n");

        script.push_str("  .init_array :\n");
        script.push_str("  {\n");
        script.push_str("    PROVIDE_HIDDEN (__init_array_start = .);\n");
        script.push_str("    KEEP (*(SORT(.init_array.*)))\n");
        script.push_str("    KEEP (*(.init_array*))\n");
        script.push_str("    PROVIDE_HIDDEN (__init_array_end = .);\n");
        script.push_str("  } >FLASH\n\n");

        script.push_str("  .fini_array :\n");
        script.push_str("  {\n");
        script.push_str("    PROVIDE_HIDDEN (__fini_array_start = .);\n");
        script.push_str("    KEEP (*(SORT(.fini_array.*)))\n");
        script.push_str("    KEEP (*(.fini_array*))\n");
        script.push_str("    PROVIDE_HIDDEN (__fini_array_end = .);\n");
        script.push_str("  } >FLASH\n\n");

        // Load address for .data initialization
        script.push_str("  _sidata = LOADADDR(.data);\n\n");

        // .data section (initialized data)
        script.push_str("  .data :\n");
        script.push_str("  {\n");
        script.push_str("    . = ALIGN(4);\n");
        script.push_str("    _sdata = .;        /* Start of data section */\n");
        script.push_str("    *(.data)\n");
        script.push_str("    *(.data*)\n");
        script.push_str("    . = ALIGN(4);\n");
        script.push_str("    _edata = .;        /* End of data section */\n");
        script.push_str("  } >RAM AT> FLASH\n\n");

        // .bss section (zero-initialized data)
        script.push_str("  .bss :\n");
        script.push_str("  {\n");
        script.push_str("    . = ALIGN(4);\n");
        script.push_str("    _sbss = .;         /* Start of BSS section */\n");
        script.push_str("    __bss_start__ = _sbss;\n");
        script.push_str("    *(.bss)\n");
        script.push_str("    *(.bss*)\n");
        script.push_str("    *(COMMON)\n");
        script.push_str("    . = ALIGN(4);\n");
        script.push_str("    _ebss = .;         /* End of BSS section */\n");
        script.push_str("    __bss_end__ = _ebss;\n");
        script.push_str("  } >RAM\n\n");

        // Heap section (if enabled)
        if self.heap_size > 0 {
            script.push_str("  .heap :\n");
            script.push_str("  {\n");
            script.push_str("    . = ALIGN(4);\n");
            script.push_str("    _sheap = .;\n");
            script.push_str("    . = . + _heap_size;\n");
            script.push_str("    . = ALIGN(4);\n");
            script.push_str("    _eheap = .;\n");
            script.push_str("  } >RAM\n\n");
        }

        // Stack (grows downward from end of RAM)
        script.push_str("  .stack :\n");
        script.push_str("  {\n");
        script.push_str("    . = ALIGN(8);\n");
        script.push_str("    _sstack = .;\n");
        script.push_str("    . = . + _stack_size;\n");
        script.push_str("    . = ALIGN(8);\n");
        script.push_str("    _estack = .;\n");
        script.push_str("  } >RAM\n\n");

        // Remove debugging symbols
        script.push_str("  /DISCARD/ :\n");
        script.push_str("  {\n");
        script.push_str("    libc.a ( * )\n");
        script.push_str("    libm.a ( * )\n");
        script.push_str("    libgcc.a ( * )\n");
        script.push_str("  }\n\n");

        // Attributes
        script.push_str("  .ARM.attributes 0 : { *(.ARM.attributes) }\n");

        script.push_str("}\n");

        Ok(script)
    }

    /// Generate and write to a file
    pub fn generate_to_file(&self, path: &str) -> Result<()> {
        let script = self.generate()?;
        std::fs::write(path, script)?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_linker_script_generation() {
        let generator = LinkerScriptGenerator::new_stm32();
        let script = generator.generate().expect("Failed to generate");

        assert!(script.contains("ENTRY(Reset_Handler)"));
        assert!(script.contains("MEMORY"));
        assert!(script.contains("FLASH"));
        assert!(script.contains("RAM"));
        assert!(script.contains("SECTIONS"));
    }

    #[test]
    fn test_custom_memory_regions() {
        let mut generator = LinkerScriptGenerator::new();
        generator.add_region(MemoryRegion {
            name: "FLASH".to_string(),
            origin: 0x08000000,
            length: 1024 * 1024,
            attributes: "rx".to_string(),
        });

        let script = generator.generate().expect("Failed to generate");
        assert!(script.contains("FLASH"));
        assert!(script.contains("0x08000000"));
    }

    #[test]
    fn test_entry_point() {
        let generator = LinkerScriptGenerator::new_stm32()
            .with_entry_point("main".to_string());

        let script = generator.generate().expect("Failed to generate");
        assert!(script.contains("ENTRY(main)"));
    }

    #[test]
    fn test_stack_configuration() {
        let generator = LinkerScriptGenerator::new_stm32()
            .with_stack_size(8192);

        let script = generator.generate().expect("Failed to generate");
        assert!(script.contains("_stack_size = 0x2000")); // 8192 = 0x2000
    }

    #[test]
    fn test_heap_configuration() {
        let generator = LinkerScriptGenerator::new_stm32()
            .with_heap_size(16384);

        let script = generator.generate().expect("Failed to generate");
        assert!(script.contains("_heap_size = 0x4000")); // 16384 = 0x4000
        assert!(script.contains(".heap"));
    }

    #[test]
    fn test_section_alignment() {
        let generator = LinkerScriptGenerator::new_stm32();
        let script = generator.generate().expect("Failed to generate");

        // Vector table must be 128-byte aligned
        assert!(script.contains("ALIGN(128)"));
        // Other sections should be 4-byte aligned
        assert!(script.contains("ALIGN(4)"));
    }

    #[test]
    fn test_data_section_initialization() {
        let generator = LinkerScriptGenerator::new_stm32();
        let script = generator.generate().expect("Failed to generate");

        // Data section should have load address
        assert!(script.contains("_sidata"));
        assert!(script.contains("_sdata"));
        assert!(script.contains("_edata"));
        assert!(script.contains(">RAM AT> FLASH"));
    }

    #[test]
    fn test_bss_section() {
        let generator = LinkerScriptGenerator::new_stm32();
        let script = generator.generate().expect("Failed to generate");

        assert!(script.contains(".bss"));
        assert!(script.contains("_sbss"));
        assert!(script.contains("_ebss"));
    }

    #[test]
    fn test_isr_vector_section() {
        let generator = LinkerScriptGenerator::new_stm32();
        let script = generator.generate().expect("Failed to generate");

        assert!(script.contains(".isr_vector"));
        assert!(script.contains("KEEP(*(.isr_vector))"));
    }
}
