(** Synth Minimal WASM Compiler - POC Version

    Compiles a simple WASM function to ARM assembly

    Usage: synth_compile input.wasm -o output.s
*)

open ArmState
open ArmInstructions
open WasmInstructions
open Compilation

(** Convert ARM register to assembly string *)
let reg_to_string = function
  | R0 -> "r0"
  | R1 -> "r1"
  | R2 -> "r2"
  | R3 -> "r3"
  | R4 -> "r4"
  | R5 -> "r5"
  | R6 -> "r6"
  | R7 -> "r7"
  | R8 -> "r8"
  | R9 -> "r9"
  | R10 -> "r10"
  | R11 -> "r11"
  | R12 -> "r12"
  | SP -> "sp"
  | LR -> "lr"
  | PC -> "pc"

(** Convert operand2 to assembly string *)
let operand2_to_string = function
  | Imm n -> Printf.sprintf "#%d" n
  | Reg r -> reg_to_string r
  | RegShift (r, shift) -> Printf.sprintf "%s, lsl #%d" (reg_to_string r) shift

(** Convert ARM instruction to assembly string *)
let instr_to_asm = function
  | ADD (rd, rn, op2) ->
      Printf.sprintf "    add %s, %s, %s"
        (reg_to_string rd) (reg_to_string rn) (operand2_to_string op2)

  | SUB (rd, rn, op2) ->
      Printf.sprintf "    sub %s, %s, %s"
        (reg_to_string rd) (reg_to_string rn) (operand2_to_string op2)

  | MOV (rd, op2) ->
      Printf.sprintf "    mov %s, %s"
        (reg_to_string rd) (operand2_to_string op2)

  | MOVW (rd, imm) ->
      Printf.sprintf "    movw %s, #%d" (reg_to_string rd) imm

  | BX r ->
      Printf.sprintf "    bx %s" (reg_to_string r)

  | _ -> "    nop  @ unimplemented instruction"

(** Generate ARM assembly for a WASM function *)
let generate_function_asm func_name wasm_instrs =
  (* Compile WASM to ARM using extracted Coq code *)
  let arm_program = compile_wasm_program wasm_instrs in

  (* Generate assembly *)
  let asm_lines = [
    Printf.sprintf ".global %s" func_name;
    Printf.sprintf ".type %s, %%function" func_name;
    Printf.sprintf "%s:" func_name;
    "    @ Function prologue";
    "    push {r4, lr}";
    "";
    "    @ WASM function body";
  ] in

  (* Convert each ARM instruction to assembly *)
  let body_asm = List.map instr_to_asm arm_program in

  (* Function epilogue *)
  let epilogue = [
    "";
    "    @ Function epilogue";
    "    pop {r4, pc}";
    Printf.sprintf ".size %s, .-%s" func_name func_name;
  ] in

  String.concat "\n" (asm_lines @ body_asm @ epilogue)

(** Main compiler entry point *)
let compile_wasm_file input_file output_file =
  (* For this POC, we'll hardcode a simple add function *)
  (* Real implementation would parse the WASM file *)

  Printf.printf "Synth Compiler - POC Version\n";
  Printf.printf "Compiling: %s -> %s\n" input_file output_file;

  (* Hardcoded: add function body *)
  (* WASM: (func $add (param i32 i32) (result i32)
            local.get 0
            local.get 1
            i32.add
          )

     But our stack-based model expects:
     - R0 = first param (already there)
     - R1 = second param (already there)
     - Result in R0
  *)

  let wasm_body = [I32Add] in  (* Just add R0 + R1 *)

  (* Generate assembly *)
  let asm_header = [
    "@ Generated by Synth WASM Compiler";
    "@ Target: ARM Cortex-M";
    "";
    ".syntax unified";
    ".thumb";
    ".text";
    "";
  ] in

  let func_asm = generate_function_asm "synth_add" wasm_body in

  let full_asm = String.concat "\n" asm_header ^ "\n" ^ func_asm in

  (* Write to output file *)
  let oc = open_out output_file in
  output_string oc full_asm;
  close_out oc;

  Printf.printf "âœ“ Compilation successful!\n";
  Printf.printf "Generated ARM assembly: %s\n" output_file;
  Printf.printf "\nTo assemble:\n";
  Printf.printf "  arm-none-eabi-as -mcpu=cortex-m4 -mthumb %s -o add.o\n" output_file;
  ()

(** Command-line interface *)
let () =
  if Array.length Sys.argv < 3 then begin
    Printf.eprintf "Usage: %s <input.wasm> -o <output.s>\n" Sys.argv.(0);
    exit 1
  end;

  let input_file = Sys.argv.(1) in
  let output_file =
    if Array.length Sys.argv >= 4 && Sys.argv.(2) = "-o" then
      Sys.argv.(3)
    else
      "output.s"
  in

  compile_wasm_file input_file output_file
